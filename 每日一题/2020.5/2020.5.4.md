### 2020.5.4 45. 跳跃游戏 II

#### 算法一：动态规划

这道题一看就是有限集合的最优化问题，所以想到用动态规划，定义`f[i]`为调到点`i`需要的最小步数。

**时间复杂度：$O(n^2)$**

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n, 0x3f3f3f3f);
        for (int i = 0; i < n; i++) {
            if (!i) f[i] = 0;
            else {
                for (int j = 0; j < i; j++) {
                    if (j + nums[j] >= i) {
                        f[i] = min(f[i], f[j] + 1);
                    }
                }
            }
        }
        return f[n - 1];
    }
};
```

#### 算法二：动态规划+贪心

很遗憾超时了，所以想办法优化。

我们会发现`f[i]`是具有单调性的，也就是`f[i + 1] >= f[i]`。用反证法：假设`f[i + 1] < f[i]`，不妨设是从`k,(k <= i)`点跳到`i + 1`，即：`k + nums[k] >= i + 1`，那么`k + nums[k]`也必然大于`i`，此时：`f[i + 1] = f[i]`了。如果`nums`数组每一项都为`1`，则：`f[i + 1] > f[i]`，综上：`f[i + 1] >= f[i]`，与假设矛盾。

因此`f[i]`就变成了`0 1...1 2...2 3...3 ......`，在动态规划时瓶颈就在于更新每个点的最小值时需要遍历所有能跳到`i`的点，而有了单调性以后就可以用第一个能调到`i`的点更新了。

**时间复杂度：$O(n)$**

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n);
        for (int i = 0, last = 0; i < n; i++) {
            if (!i) f[i] = 0;
            else {
                while (last < n && last + nums[last] < i) last++;
                f[i] = f[last] + 1;
            }
        }
        return f[n - 1];
    }
};
```

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int[] f = new int[n];
        for (int i = 0, last = 0; i < n; i++) {
            if (i == 0) f[i] = 0;
            else {
                while (last < n && last + nums[last] < i) last++;
                f[i] = f[last] + 1;
            }
        }
        return f[n - 1];
    }
}
```